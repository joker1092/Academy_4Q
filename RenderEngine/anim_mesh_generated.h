// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMMESH_ANIMMESHBUILD_H_
#define FLATBUFFERS_GENERATED_ANIMMESH_ANIMMESHBUILD_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
    FLATBUFFERS_VERSION_MINOR == 12 &&
    FLATBUFFERS_VERSION_REVISION == 23,
    "Non-compatible flatbuffers version included");

namespace AnimMeshBuild {

    struct Float2;

    struct Float3;

    struct AnimVertex;
    struct AnimVertexBuilder;

    struct AnimMesh;
    struct AnimMeshBuilder;

    FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float2 FLATBUFFERS_FINAL_CLASS {
    private:
        float x_;
        float y_;

    public:
        Float2()
            : x_(0),
            y_(0) {
        }
        Float2(float _x, float _y)
            : x_(::flatbuffers::EndianScalar(_x)),
            y_(::flatbuffers::EndianScalar(_y)) {
        }
        float x() const {
            return ::flatbuffers::EndianScalar(x_);
        }
        float y() const {
            return ::flatbuffers::EndianScalar(y_);
        }
    };
    FLATBUFFERS_STRUCT_END(Float2, 8);

    FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float3 FLATBUFFERS_FINAL_CLASS {
    private:
        float x_;
        float y_;
        float z_;

    public:
        Float3()
            : x_(0),
            y_(0),
            z_(0) {
        }
        Float3(float _x, float _y, float _z)
            : x_(::flatbuffers::EndianScalar(_x)),
            y_(::flatbuffers::EndianScalar(_y)),
            z_(::flatbuffers::EndianScalar(_z)) {
        }
        float x() const {
            return ::flatbuffers::EndianScalar(x_);
        }
        float y() const {
            return ::flatbuffers::EndianScalar(y_);
        }
        float z() const {
            return ::flatbuffers::EndianScalar(z_);
        }
    };
    FLATBUFFERS_STRUCT_END(Float3, 12);

    struct AnimVertex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
        typedef AnimVertexBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_POSITION = 4,
            VT_NORMAL = 6,
            VT_TANGENT = 8,
            VT_BITANGENT = 10,
            VT_TEXCOORD = 12,
            VT_BONEINDEX = 14,
            VT_BONEWEIGHT = 16
        };
        const AnimMeshBuild::Float3* position() const {
            return GetStruct<const AnimMeshBuild::Float3*>(VT_POSITION);
        }
        const AnimMeshBuild::Float3* normal() const {
            return GetStruct<const AnimMeshBuild::Float3*>(VT_NORMAL);
        }
        const AnimMeshBuild::Float3* tangent() const {
            return GetStruct<const AnimMeshBuild::Float3*>(VT_TANGENT);
        }
        const AnimMeshBuild::Float3* bitangent() const {
            return GetStruct<const AnimMeshBuild::Float3*>(VT_BITANGENT);
        }
        const AnimMeshBuild::Float2* texcoord() const {
            return GetStruct<const AnimMeshBuild::Float2*>(VT_TEXCOORD);
        }
        const ::flatbuffers::Vector<int32_t>* boneIndex() const {
            return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_BONEINDEX);
        }
        const ::flatbuffers::Vector<float>* boneWeight() const {
            return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BONEWEIGHT);
        }
        bool Verify(::flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) &&
                VerifyField<AnimMeshBuild::Float3>(verifier, VT_POSITION, 4) &&
                VerifyField<AnimMeshBuild::Float3>(verifier, VT_NORMAL, 4) &&
                VerifyField<AnimMeshBuild::Float3>(verifier, VT_TANGENT, 4) &&
                VerifyField<AnimMeshBuild::Float3>(verifier, VT_BITANGENT, 4) &&
                VerifyField<AnimMeshBuild::Float2>(verifier, VT_TEXCOORD, 4) &&
                VerifyOffset(verifier, VT_BONEINDEX) &&
                verifier.VerifyVector(boneIndex()) &&
                VerifyOffset(verifier, VT_BONEWEIGHT) &&
                verifier.VerifyVector(boneWeight()) &&
                verifier.EndTable();
        }
    };

    struct AnimVertexBuilder {
        typedef AnimVertex Table;
        ::flatbuffers::FlatBufferBuilder& fbb_;
        ::flatbuffers::uoffset_t start_;
        void add_position(const AnimMeshBuild::Float3* position) {
            fbb_.AddStruct(AnimVertex::VT_POSITION, position);
        }
        void add_normal(const AnimMeshBuild::Float3* normal) {
            fbb_.AddStruct(AnimVertex::VT_NORMAL, normal);
        }
        void add_tangent(const AnimMeshBuild::Float3* tangent) {
            fbb_.AddStruct(AnimVertex::VT_TANGENT, tangent);
        }
        void add_bitangent(const AnimMeshBuild::Float3* bitangent) {
            fbb_.AddStruct(AnimVertex::VT_BITANGENT, bitangent);
        }
        void add_texcoord(const AnimMeshBuild::Float2* texcoord) {
            fbb_.AddStruct(AnimVertex::VT_TEXCOORD, texcoord);
        }
        void add_boneIndex(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> boneIndex) {
            fbb_.AddOffset(AnimVertex::VT_BONEINDEX, boneIndex);
        }
        void add_boneWeight(::flatbuffers::Offset<::flatbuffers::Vector<float>> boneWeight) {
            fbb_.AddOffset(AnimVertex::VT_BONEWEIGHT, boneWeight);
        }
        explicit AnimVertexBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        ::flatbuffers::Offset<AnimVertex> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = ::flatbuffers::Offset<AnimVertex>(end);
            return o;
        }
    };

    inline ::flatbuffers::Offset<AnimVertex> CreateAnimVertex(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        const AnimMeshBuild::Float3* position = nullptr,
        const AnimMeshBuild::Float3* normal = nullptr,
        const AnimMeshBuild::Float3* tangent = nullptr,
        const AnimMeshBuild::Float3* bitangent = nullptr,
        const AnimMeshBuild::Float2* texcoord = nullptr,
        ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> boneIndex = 0,
        ::flatbuffers::Offset<::flatbuffers::Vector<float>> boneWeight = 0) {
        AnimVertexBuilder builder_(_fbb);
        builder_.add_boneWeight(boneWeight);
        builder_.add_boneIndex(boneIndex);
        builder_.add_texcoord(texcoord);
        builder_.add_bitangent(bitangent);
        builder_.add_tangent(tangent);
        builder_.add_normal(normal);
        builder_.add_position(position);
        return builder_.Finish();
    }

    inline ::flatbuffers::Offset<AnimVertex> CreateAnimVertexDirect(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        const AnimMeshBuild::Float3* position = nullptr,
        const AnimMeshBuild::Float3* normal = nullptr,
        const AnimMeshBuild::Float3* tangent = nullptr,
        const AnimMeshBuild::Float3* bitangent = nullptr,
        const AnimMeshBuild::Float2* texcoord = nullptr,
        const std::vector<int32_t>* boneIndex = nullptr,
        const std::vector<float>* boneWeight = nullptr) {
        auto boneIndex__ = boneIndex ? _fbb.CreateVector<int32_t>(*boneIndex) : 0;
        auto boneWeight__ = boneWeight ? _fbb.CreateVector<float>(*boneWeight) : 0;
        return AnimMeshBuild::CreateAnimVertex(
            _fbb,
            position,
            normal,
            tangent,
            bitangent,
            texcoord,
            boneIndex__,
            boneWeight__);
    }

    struct AnimMesh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
        typedef AnimMeshBuilder Builder;
        enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
            VT_VERTICES = 4
        };
        const ::flatbuffers::Vector<::flatbuffers::Offset<AnimMeshBuild::AnimVertex>>* vertices() const {
            return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AnimMeshBuild::AnimVertex>> *>(VT_VERTICES);
        }
        bool Verify(::flatbuffers::Verifier& verifier) const {
            return VerifyTableStart(verifier) &&
                VerifyOffset(verifier, VT_VERTICES) &&
                verifier.VerifyVector(vertices()) &&
                verifier.VerifyVectorOfTables(vertices()) &&
                verifier.EndTable();
        }
    };

    struct AnimMeshBuilder {
        typedef AnimMesh Table;
        ::flatbuffers::FlatBufferBuilder& fbb_;
        ::flatbuffers::uoffset_t start_;
        void add_vertices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AnimMeshBuild::AnimVertex>>> vertices) {
            fbb_.AddOffset(AnimMesh::VT_VERTICES, vertices);
        }
        explicit AnimMeshBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
            : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        ::flatbuffers::Offset<AnimMesh> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = ::flatbuffers::Offset<AnimMesh>(end);
            return o;
        }
    };

    inline ::flatbuffers::Offset<AnimMesh> CreateAnimMesh(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AnimMeshBuild::AnimVertex>>> vertices = 0) {
        AnimMeshBuilder builder_(_fbb);
        builder_.add_vertices(vertices);
        return builder_.Finish();
    }

    inline ::flatbuffers::Offset<AnimMesh> CreateAnimMeshDirect(
        ::flatbuffers::FlatBufferBuilder& _fbb,
        const std::vector<::flatbuffers::Offset<AnimMeshBuild::AnimVertex>>* vertices = nullptr) {
        auto vertices__ = vertices ? _fbb.CreateVector<::flatbuffers::Offset<AnimMeshBuild::AnimVertex>>(*vertices) : 0;
        return AnimMeshBuild::CreateAnimMesh(
            _fbb,
            vertices__);
    }

    inline const AnimMeshBuild::AnimMesh* GetAnimMesh(const void* buf) {
        return ::flatbuffers::GetRoot<AnimMeshBuild::AnimMesh>(buf);
    }

    inline const AnimMeshBuild::AnimMesh* GetSizePrefixedAnimMesh(const void* buf) {
        return ::flatbuffers::GetSizePrefixedRoot<AnimMeshBuild::AnimMesh>(buf);
    }

    inline bool VerifyAnimMeshBuffer(
        ::flatbuffers::Verifier& verifier) {
        return verifier.VerifyBuffer<AnimMeshBuild::AnimMesh>(nullptr);
    }

    inline bool VerifySizePrefixedAnimMeshBuffer(
        ::flatbuffers::Verifier& verifier) {
        return verifier.VerifySizePrefixedBuffer<AnimMeshBuild::AnimMesh>(nullptr);
    }

    inline void FinishAnimMeshBuffer(
        ::flatbuffers::FlatBufferBuilder& fbb,
        ::flatbuffers::Offset<AnimMeshBuild::AnimMesh> root) {
        fbb.Finish(root);
    }

    inline void FinishSizePrefixedAnimMeshBuffer(
        ::flatbuffers::FlatBufferBuilder& fbb,
        ::flatbuffers::Offset<AnimMeshBuild::AnimMesh> root) {
        fbb.FinishSizePrefixed(root);
    }

}  // namespace AnimMeshBuild

#endif  // FLATBUFFERS_GENERATED_ANIMMESH_ANIMMESHBUILD_H_
